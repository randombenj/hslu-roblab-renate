#!/usr/bin/env python
# Class autogenerated from /home/sam/Downloads/aldebaran_sw/nao/naoqi-sdk-2.1.4.13-linux64/include/alproxies/almotionproxy.h
# by Sammy Pfeiffer's <Sammy.Pfeiffer at student.uts.edu.au> generator
# You need an ALBroker running

from naoqi import ALProxy



class ALMotion(object):
    def __init__(self, session):
        self.proxy = None 
        self.session = session

    def force_connect(self):
        self.proxy = self.session.service("ALMotion")

    def angleInterpolation(self, names, angleLists, timeLists, isAbsolute):
        """Interpolates one or multiple joints to a target angle or along timed trajectories. This is a blocking call.

        :param AL::ALValue names: Name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue angleLists: An angle, list of angles or list of list of angles in radians
        :param AL::ALValue timeLists: A time, list of times or list of list of times in seconds
        :param bool isAbsolute: If true, the movement is described in absolute angles, else the angles are relative to the current angle.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.angleInterpolation(names, angleLists, timeLists, isAbsolute)

    def angleInterpolationBezier(self, jointNames, times, controlPoints):
        """Interpolates a sequence of timed angles for several motors using bezier control points. This is a blocking call.

        :param std::vector<std::string> jointNames: A vector of joint names
        :param AL::ALValue times: An ragged ALValue matrix of floats. Each line corresponding to a motor, and column element to a control point.
        :param AL::ALValue controlPoints: An ALValue array of arrays each containing [float angle, Handle1, Handle2], where Handle is [int InterpolationType, float dAngle, float dTime] descibing the handle offsets relative to the angle and time of the point. The first bezier param describes the handle that controls the curve preceeding the point, the second describes the curve following the point.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.angleInterpolationBezier(jointNames, times, controlPoints)

    def angleInterpolationWithSpeed(self, names, targetAngles, maxSpeedFraction):
        """Interpolates one or multiple joints to a target angle, using a fraction of max speed. Only one target angle is allowed for each joint. This is a blocking call.

        :param AL::ALValue names: Name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue targetAngles: An angle, or list of angles in radians
        :param float maxSpeedFraction: A fraction.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.angleInterpolationWithSpeed(names, targetAngles, maxSpeedFraction)

    def areNotificationsEnabled(self):
        """Return true if notifications are active.

        :returns bool: Return True if notifications are active.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.areNotificationsEnabled()

    def areResourcesAvailable(self, resourceNames):
        """Returns true if all the desired resources are available. Only motion API's' blocking call takes resources.

        :param std::vector<std::string> resourceNames: A vector of resource names such as joints. Use getBodyNames("Body") to have the list of the available joint for your robot.
        :returns bool: True if the resources are available
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.areResourcesAvailable(resourceNames)

    def changeAngles(self, names, changes, fractionMaxSpeed):
        """Changes Angles. This is a non-blocking call.

        :param AL::ALValue names: The name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue changes: One or more changes in radians
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.changeAngles(names, changes, fractionMaxSpeed)

    def changePosition(self, effectorName, space, positionChange, fractionMaxSpeed, axisMask):
        """DEPRECATED. Use setPositions function instead.

        :param str effectorName: Name of the effector.
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param std::vector<float> positionChange: 6D position change array (xd, yd, zd, wxd, wyd, wzd) in meters and radians
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.changePosition(effectorName, space, positionChange, fractionMaxSpeed, axisMask)

    def changeTransform(self, chainName, space, transform, fractionMaxSpeed, axisMask):
        """DEPRECATED. Use setTransforms function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param std::vector<float> transform: Transform arrays
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.changeTransform(chainName, space, transform, fractionMaxSpeed, axisMask)

    def closeHand(self, handName):
        """NAO stiffens the motors of desired hand. Then, he closes the hand, then cuts motor current to conserve energy. This is a blocking call.

        :param str handName: The name of the hand. Could be: "RHand" or "LHand"
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.closeHand(handName)

    def getAngles(self, names, useSensors):
        """Gets the angles of the joints

        :param AL::ALValue names: Names the joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param bool useSensors: If true, sensor angles will be returned
        :returns std::vector<float>: Joint angles in radians.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getAngles(names, useSensors)

    def getBodyNames(self, name):
        """Gets the names of all the joints and actuators in the collection.

        :param str name: Name of a chain, "Arms", "Legs", "Body", "Chains", "JointActuators", "Joints" or "Actuators".
        :returns std::vector<std::string>: Vector of strings, one for each joint and actuator in the collection
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getBodyNames(name)

    def getBreathConfig(self):
        """This function gets the current breathing session. bpm is the breathing frequency in beats per minute. amplitude is the normalized amplitude of the breathing animation, between 0 and 1.

        :returns AL::ALValue: An ALValue of the form [["Bpm", bpm], ["Amplitude", amplitude]].
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getBreathConfig()

    def getBreathEnabled(self, pChain):
        """This function gets the status of breathing animation on a chain. Chain name can be "Body", "Arms", "LArm", "RArm", "Legs" or "Head".

        :param str pChain: Chain name.
        :returns bool: True if breathing animation is enabled on the chain.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getBreathEnabled(pChain)

    def getCOM(self, pName, pSpace, pUseSensorValues):
        """Gets the COM of a joint, chain, "Body" or "Joints".

        :param str pName: Name of the body which we want the mass. In chain name case, this function give the com of the chain.
        :param int pSpace: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param bool pUseSensorValues: If true, the sensor values will be used to determine the position.
        :returns std::vector<float>: The COM position (meter).
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getCOM(pName, pSpace, pUseSensorValues)

    def getChainClosestObstaclePosition(self, pName, space):
        """Gets chain closest obstacle Position .

        :param str pName: The Chain name {"LArm" or "RArm"}.
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :returns std::vector<float>: Vector containing the Position3D in meters (x, y, z)
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getChainClosestObstaclePosition(pName, space)

    def getCollisionProtectionEnabled(self, pChainName):
        """Allow to know if the collision protection is activated on the given chain.

        :param str pChainName: The chain name {"LArm" or "RArm"}.
        :returns bool: Return true is the collision protection of the given Arm is activated.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getCollisionProtectionEnabled(pChainName)

    def getDiagnosisEffectEnabled(self):
        """Give the state of the diagnosis effect.

        :returns bool: Return true is the diagnosis reflex is activated.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getDiagnosisEffectEnabled()

    def getExternalCollisionProtectionEnabled(self, pName):
        """Allow to know if the external collision protection is activated on the given name.

        :param str pName: The name {"All", "Move", "Arms", "LArm" or "RArm"}.
        :returns bool: Return true is the external collision protection of the given name is activated.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getExternalCollisionProtectionEnabled(pName)

    def getFallManagerEnabled(self):
        """Give the state of the fall manager.

        :returns bool: Return true is the fall manager is activated.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getFallManagerEnabled()

    def getFootGaitConfig(self, config):
        """DEPRECATED. Use getMoveConfig function instead. Gets the foot Gait config ("MaxStepX", "MaxStepY", "MaxStepTheta",  "MaxStepFrequency", "StepHeight", "TorsoWx", "TorsoWy")

        :param str config: a string should be "Max", "Min", "Default"  ["MaxStepY", value],  ["MaxStepTheta", value],  ["MaxStepFrequency", value],  ["StepHeight", value],  ["TorsoWx", value],  ["TorsoWy", value]]
        :returns AL::ALValue: An ALvalue with the following form :[["MaxStepX", value],
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getFootGaitConfig(config)

    def getFootSteps(self):
        """Get the foot steps. This is a non-blocking call.

        :returns AL::ALValue: Give two list of foot steps. The first one give the unchangeable foot step. The second list give the changeable foot steps. Il you use setFootSteps or setFootStepsWithSpeed with clearExisting parmater equal true, walk engine execute unchangeable foot step and remove the other.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getFootSteps()

    def getIdlePostureEnabled(self, pChain):
        """This function gets the status of idle posture management on a chain. Chain name can be "Body", "Arms", "LArm", "RArm", "Legs" or "Head".

        :param str pChain: Chain name.
        :returns bool: True if breathing animation is enabled on the chain.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getIdlePostureEnabled(pChain)

    def getJointNames(self, name):
        """DEPRECATED. Use getBodyNames function instead.

        :param str name: Name of a chain, "Arms", "Legs", "Body", "Chains", "JointActuators", "Joints" or "Actuators".
        :returns std::vector<std::string>: Vector of strings, one for each joint in the collection
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getJointNames(name)

    def getLimits(self, name):
        """Get the minAngle (rad), maxAngle (rad), and maxVelocity (rad.s-1) for a given joint or actuator in the body.

        :param str name: Name of a joint, chain, "Body", "JointActuators", "Joints" or "Actuators".
        :returns AL::ALValue: Array of ALValue arrays containing the minAngle, maxAngle, maxVelocity and maxTorque for all the bodies specified.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getLimits(name)

    def getMass(self, pName):
        """Gets the mass of a joint, chain, "Body" or "Joints".

        :param str pName: Name of the body which we want the mass. "Body", "Joints" and "Com" give the total mass of nao. For the chain, it gives the total mass of the chain.
        :returns float: The mass in kg.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getMass(pName)

    def getMotionCycleTime(self):
        """Get the motion cycle time in milliseconds.

        :returns int: Expressed in milliseconds
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getMotionCycleTime()

    def getMoveArmsEnabled(self, chainName):
        """Gets if Arms Motions are enabled during the Move Process.

        :param str chainName: Name of the chain. Could be: "LArm", "RArm" or "Arms"
        :returns bool: For LArm and RArm true if the corresponding arm is enabled. For Arms, true if both are enabled. False otherwise.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getMoveArmsEnabled(chainName)

    def getMoveConfig(self, config):
        """Gets the move config.

        :param str config: a string should be "Max", "Min", "Default"
        :returns AL::ALValue: An ALvalue with the move config
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getMoveConfig(config)

    def getNextRobotPosition(self):
        """Gets the World Absolute next Robot Position. In fact in the walk algorithm some foot futur foot step are incompressible due to preview control, so this function give the next robot position which is incompressible. If the robot doesn't walk this function is equivalent to getRobotPosition(false)

        :returns std::vector<float>: A vector containing the World Absolute next Robot position.(Absolute Position X, Absolute Position Y, Absolute Angle Z)
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getNextRobotPosition()

    def getOrthogonalSecurityDistance(self):
        """Gets the current orthogonal security distance.

        :returns float: The current orthogonal security distance.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getOrthogonalSecurityDistance()

    def getPosition(self, name, space, useSensorValues):
        """Gets a Position relative to the FRAME. Axis definition: the x axis is positive toward Nao's front, the y from right to left and the z is vertical. The angle convention of Position6D is Rot_z(wz).Rot_y(wy).Rot_x(wx).

        :param str name: Name of the item. Could be: Head, LArm, RArm, LLeg, RLeg, Torso, CameraTop, CameraBottom, MicroFront, MicroRear, MicroLeft, MicroRight, Accelerometer, Gyrometer, Laser, LFsrFR, LFsrFL, LFsrRR, LFsrRL, RFsrFR, RFsrFL, RFsrRR, RFsrRL, USSensor1, USSensor2, USSensor3, USSensor4. Use getSensorNames for the list of sensors supported on your robot.
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param bool useSensorValues: If true, the sensor values will be used to determine the position.
        :returns std::vector<float>: Vector containing the Position6D using meters and radians (x, y, z, wx, wy, wz)
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getPosition(name, space, useSensorValues)

    def getPushRecoveryEnabled(self):
        """Give the state of the push recovery.

        :returns bool: Return true is the push recovery is activated.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getPushRecoveryEnabled()

    def getRobotConfig(self):
        """Get the robot session.

        :returns AL::ALValue: ALValue arrays containing the robot parameter names and the robot parameter values.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getRobotConfig()

    def getRobotPosition(self, useSensors):
        """Gets the World Absolute Robot Position.

        :param bool useSensors: If true, use the sensor values
        :returns std::vector<float>: A vector containing the World Absolute Robot Position. (Absolute Position X, Absolute Position Y, Absolute Angle Z)
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getRobotPosition(useSensors)

    def getRobotVelocity(self):
        """Gets the World Absolute Robot Velocity.

        :returns std::vector<float>: A vector containing the World Absolute Robot Velocity. (Absolute Velocity Translation X [m.s-1], Absolute Velocity Translation Y[m.s-1], Absolute Velocity Rotation WZ [rd.s-1])
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getRobotVelocity()

    def getSensorNames(self):
        """Gets the list of sensors supported on your robot.

        :returns std::vector<std::string>: Vector of sensor names
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getSensorNames()

    def getSmartStiffnessEnabled(self):
        """Give the state of the smart Stiffness.

        :returns bool: Return true is the smart Stiffnes is activated.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getSmartStiffnessEnabled()

    def getStiffnesses(self, jointName):
        """Gets stiffness of a joint or group of joints

        :param AL::ALValue jointName: Name of the joints, chains, "Body", "Joints" or "Actuators".
        :returns std::vector<float>: One or more stiffnesses. 1.0 indicates maximum stiffness. 0.0 indicated minimum stiffness
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getStiffnesses(jointName)

    def getSummary(self):
        """Returns a string representation of the Model's state

        :returns str: A formated string
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getSummary()

    def getTangentialSecurityDistance(self):
        """Gets the current tangential security distance.

        :returns float: The current tangential security distance.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getTangentialSecurityDistance()

    def getTaskList(self):
        """Gets an ALValue structure describing the tasks in the Task List

        :returns AL::ALValue: An ALValue containing an ALValue for each task. The inner ALValue contains: Name, MotionID
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getTaskList()

    def getTransform(self, name, space, useSensorValues):
        """Gets an Homogenous Transform relative to the FRAME. Axis definition: the x axis is positive toward Nao's front, the y from right to left and the z is vertical.

        :param str name: Name of the item. Could be: any joint or chain or sensor (Head, LArm, RArm, LLeg, RLeg, Torso, HeadYaw, ..., CameraTop, CameraBottom, MicroFront, MicroRear, MicroLeft, MicroRight, Accelerometer, Gyrometer, Laser, LFsrFR, LFsrFL, LFsrRR, LFsrRL, RFsrFR, RFsrFL, RFsrRR, RFsrRL, USSensor1, USSensor2, USSensor3, USSensor4. Use getSensorNames for the list of sensors supported on your robot.
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param bool useSensorValues: If true, the sensor values will be used to determine the position.
        :returns std::vector<float>: Vector of 16 floats corresponding to the values of the matrix, line by line.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getTransform(name, space, useSensorValues)

    def getWalkArmsEnabled(self):
        """DEPRECATED. Gets if Arms Motions are enabled during the Walk Process.

        :returns AL::ALValue: True Arm Motions are controlled by the Walk Task.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.getWalkArmsEnabled()

    def isCollision(self, pChainName):
        """Give the collision state of a chain. If a chain has a collision state "none" or "near", it could be desactivated.

        :param str pChainName: The chain name {"Arms", "LArm" or "RArm"}.
        :returns str: A string which notice the collision state: "none" there are no collision, "near" the collision is taking in account in the anti-collision algorithm, "collision" the chain is in contact with an other body. If the chain asked is "Arms" the most unfavorable result is given.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.isCollision(pChainName)

    def killAll(self):
        """Kills all tasks.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.killAll()

    def killMove(self):
        """Emergency Stop on Move task: This method will end the move task brutally, without attempting to return to a balanced state. The robot could easily fall.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.killMove()

    def killTask(self, motionTaskID):
        """Kills a motion task.

        :param int motionTaskID: TaskID of the motion task you want to kill.
        :returns bool: Return true if the specified motionTaskId has been killed.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.killTask(motionTaskID)

    def killTasksUsingResources(self, resourceNames):
        """Kills all tasks that use any of the resources given. Only motion API's' blocking call takes resources and can be killed. Use getBodyNames("Body") to have the list of the available joint for your robot.

        :param std::vector<std::string> resourceNames: A vector of resource joint names
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.killTasksUsingResources(resourceNames)

    def killWalk(self):
        """DEPRECATED. Use killMove function instead.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.killWalk()

    def move(self, x, y, theta):
        """Makes the robot move at the given velocity. This is a non-blocking call.

        :param float x: The velocity along x axis [m.s-1].
        :param float y: The velocity along y axis [m.s-1].
        :param float theta: The velocity around z axis [rd.s-1].
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.move(x, y, theta)

    def move2(self, x, y, theta, moveConfig):
        """Makes the robot move at the given velocity. This is a non-blocking call.

        :param float x: The velocity along x axis [m.s-1].
        :param float y: The velocity along y axis [m.s-1].
        :param float theta: The velocity around z axis [rd.s-1].
        :param AL::ALValue moveConfig: An ALValue with custom move session.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.move(x, y, theta, moveConfig)

    def moveInit(self):
        """Initialize the move process. Check the robot pose and take a right posture. This is blocking called.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveInit()

    def moveIsActive(self):
        """Check if the move process is actif.

        :returns bool: True if move is active
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveIsActive()

    def moveTo(self, x, y, theta):
        """Makes the robot move at the given position. This is a non-blocking call.

        :param float x: The position along x axis [m].
        :param float y: The position along y axis [m].
        :param float theta: The position around z axis [rd].
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveTo(x, y, theta)

    def moveTo2(self, x, y, theta, time):
        """Makes the robot move at the given position in fixed time. This is a non-blocking call.

        :param float x: The position along x axis [m].
        :param float y: The position along y axis [m].
        :param float theta: The position around z axis [rd].
        :param float time: The time to reach the target position [s].
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveTo(x, y, theta, time)

    def moveTo3(self, x, y, theta, moveConfig):
        """Makes the robot move at the given position. This is a non-blocking call.

        :param float x: The position along x axis [m].
        :param float y: The position along y axis [m].
        :param float theta: The position around z axis [rd].
        :param AL::ALValue moveConfig: An ALValue with custom move session.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveTo(x, y, theta, moveConfig)

    def moveTo4(self, x, y, theta, time, moveConfig):
        """Makes the robot move at the given position in fixed time. This is a non-blocking call.

        :param float x: The position along x axis [m].
        :param float y: The position along y axis [m].
        :param float theta: The position around z axis [rd].
        :param float time: The time to reach the target position [s].
        :param AL::ALValue moveConfig: An ALValue with custom move session.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveTo(x, y, theta, time, moveConfig)

    def moveTo5(self, controlPoint):
        """Makes the robot move to the given relative positions. This is a blocking call.

        :param AL::ALValue controlPoint: An ALValue with the control points in FRAME_ROBOT. Each control point is relative to the previous one. [[x1, y1, theta1], ..., [xN, yN, thetaN]
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveTo(controlPoint)

    def moveTo6(self, controlPoint, moveConfig):
        """Makes the robot move to the given relative positions. This is a blocking call.

        :param AL::ALValue controlPoint: An ALValue with all the control points in FRAME_ROBOT. Each control point is relative to the previous one. [[x1, y1, theta1], ..., [xN, yN, thetaN]
        :param AL::ALValue moveConfig: An ALValue with custom move session.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveTo(controlPoint, moveConfig)

    def moveToward(self, x, y, theta):
        """Makes the robot move at the given normalized velocity. This is a non-blocking call.

        :param float x: The normalized velocity along x axis (between -1 and 1).
        :param float y: The normalized velocity along y axis (between -1 and 1).
        :param float theta: The normalized velocity around z axis (between -1 and 1).
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveToward(x, y, theta)

    def moveToward2(self, x, y, theta, moveConfig):
        """Makes the robot move at the given normalized velocity. This is a non-blocking call.

        :param float x: The normalized velocity along x axis (between -1 and 1).
        :param float y: The normalized velocity along y axis (between -1 and 1).
        :param float theta: The normalized velocity around z axis (between -1 and 1).
        :param AL::ALValue moveConfig: An ALValue with custom move session.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.moveToward(x, y, theta, moveConfig)

    def openHand(self, handName):
        """NAO stiffens the motors of desired hand. Then, he opens the hand, then cuts motor current to conserve energy. This is a blocking call.

        :param str handName: The name of the hand. Could be: "RHand or "LHand"
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.openHand(handName)

    def ping(self):
        """Just a ping. Always returns true

        :returns bool: returns true
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.ping()

    def positionInterpolation(self, chainName, space, path, axisMask, durations, isAbsolute):
        """DEPRECATED. Use positionInterpolations function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue path: Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue durations: Vector of times in seconds corresponding to the path points
        :param bool isAbsolute: If true, the movement is absolute else relative
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.positionInterpolation(chainName, space, path, axisMask, durations, isAbsolute)

    def positionInterpolations(self, effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes, isAbsolute):
        """DEPRECATED. Use the other positionInterpolations function instead.

        :param std::vector<std::string> effectorNames: Vector of chain names. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param int taskSpaceForAllPaths: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue paths: Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
        :param AL::ALValue axisMasks: Vector of Axis Masks. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue relativeTimes: Vector of times in seconds corresponding to the path points
        :param bool isAbsolute: If true, the movement is absolute else relative
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.positionInterpolations(effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes, isAbsolute)

    def positionInterpolations2(self, effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes):
        """Moves end-effectors to the given positions and orientations over time. This is a blocking call.

        :param AL::ALValue effectorNames: Vector of chain names. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param AL::ALValue taskSpaceForAllPaths: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue paths: Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
        :param AL::ALValue axisMasks: Vector of Axis Masks. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue relativeTimes: Vector of times in seconds corresponding to the path points
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.positionInterpolations(effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes)

    def rest(self):
        """The robot will rest: go to a relax and safe position and set Motor OFF
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.rest()

    def rest2(self, arg1):
        """The robot will rest: go to a relax and safe position on the chain and set Motor OFF

        :param str arg1: arg
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.rest(arg1)

    def robotIsWakeUp(self):
        """return true if the robot is already wakeUp

        :returns bool: True if the robot is already wakeUp.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.robotIsWakeUp()

    def setAngles(self, names, angles, fractionMaxSpeed):
        """Sets angles. This is a non-blocking call.

        :param AL::ALValue names: The name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue angles: One or more angles in radians
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setAngles(names, angles, fractionMaxSpeed)

    def setBreathConfig(self, pConfig):
        """This function configures the breathing animation.

        :param AL::ALValue pConfig: Breath session. An ALValue of the form [["Bpm", pBpm], ["Amplitude", pAmplitude]]. pBpm is a float between 10 and 50 setting the breathing frequency in beats per minute. pAmplitude is a float between 0 and 1 setting the amplitude of the breathing animation.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setBreathConfig(pConfig)

    def setBreathEnabled(self, pChain, pIsEnabled):
        """This function starts or stops breathing animation on a chain. Chain name can be "Body", "Arms", "LArm", "RArm", "Legs" or "Head". Head breathing animation will work only if Leg animation is active.

        :param str pChain: Chain name.
        :param bool pIsEnabled: Enables / disables the chain.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setBreathEnabled(pChain, pIsEnabled)

    def setCollisionProtectionEnabled(self, pChainName, pEnable):
        """Enable Anticollision protection of the arms of the robot. Use api isCollision to know if a chain is in collision and can be disactivated.

        :param str pChainName: The chain name {"Arms", "LArm" or "RArm"}.
        :param bool pEnable: Activate or disactivate the anticollision of the desired Chain.
        :returns bool: A bool which return always true.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setCollisionProtectionEnabled(pChainName, pEnable)

    def setDiagnosisEffectEnabled(self, pEnable):
        """Enable or disable the diagnosis effect into ALMotion

        :param bool pEnable: Enable or disable the diagnosis effect.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setDiagnosisEffectEnabled(pEnable)

    def setEnableNotifications(self, enable):
        """Enable / Disable notifications.

        :param bool enable: If True enable notifications. If False disable notifications.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setEnableNotifications(enable)

    def setExternalCollisionProtectionEnabled(self, pName, pEnable):
        """Enable Anticollision protection of the arms and base move  of the robot with external environment.

        :param str pName: The name {"All", "Move", "Arms", "LArm" or "RArm"}.
        :param bool pEnable: Activate or disactivate the anticollision of the desired name.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setExternalCollisionProtectionEnabled(pName, pEnable)

    def setFallManagerEnabled(self, pEnable):
        """Enable The fall manager protection for the robot. When a fall is detected the robot adopt a joint session to protect himself and cut the stiffness. . An memory event called "robotHasFallen" is generated when the fallManager have been activated.

        :param bool pEnable: Activate or disactivate the smart stiffness.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setFallManagerEnabled(pEnable)

    def setFootSteps(self, legName, footSteps, timeList, clearExisting):
        """Makes Nao do foot step planner. This is a non-blocking call.

        :param std::vector<std::string> legName: name of the leg to move('LLeg'or 'RLeg')
        :param AL::ALValue footSteps: [x, y, theta], [Position along X/Y, Orientation round Z axis] of the leg relative to the other Leg in [meters, meters, radians]. Must be less than [MaxStepX, MaxStepY, MaxStepTheta]
        :param std::vector<float> timeList: time list of each foot step
        :param bool clearExisting: Clear existing foot steps.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setFootSteps(legName, footSteps, timeList, clearExisting)

    def setFootStepsWithSpeed(self, legName, footSteps, fractionMaxSpeed, clearExisting):
        """Makes Nao do foot step planner with speed. This is a blocking call.

        :param std::vector<std::string> legName: name of the leg to move('LLeg'or 'RLeg')
        :param AL::ALValue footSteps: [x, y, theta], [Position along X/Y, Orientation round Z axis] of the leg relative to the other Leg in [meters, meters, radians]. Must be less than [MaxStepX, MaxStepY, MaxStepTheta]
        :param std::vector<float> fractionMaxSpeed: speed of each foot step. Must be between 0 and 1.
        :param bool clearExisting: Clear existing foot steps.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting)

    def setIdlePostureEnabled(self, pChain, pIsEnabled):
        """Starts or stops idle posture management on a chain. Chain name can be "Body", "Arms", "LArm", "RArm", "Legs" or "Head".

        :param str pChain: Chain name.
        :param bool pIsEnabled: Enables / disables the chain.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setIdlePostureEnabled(pChain, pIsEnabled)

    def setMotionConfig(self, config):
        """Internal Use.

        :param AL::ALValue config: Internal: An array of ALValues [i][0]: name, [i][1]: value
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setMotionConfig(config)

    def setMoveArmsEnabled(self, leftArmEnabled, rightArmEnabled):
        """Sets if Arms Motions are enabled during the Move Process.

        :param bool leftArmEnabled: if true Left Arm motions are controlled by the Move Task
        :param bool rightArmEnabled: if true Right Arm mMotions are controlled by the Move Task
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setMoveArmsEnabled(leftArmEnabled, rightArmEnabled)

    def setOrthogonalSecurityDistance(self, securityDistance):
        """Defines the orthogonal security distance used with external collision protection "Move".

        :param float securityDistance: The orthogonal security distance.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setOrthogonalSecurityDistance(securityDistance)

    def setPosition(self, chainName, space, position, fractionMaxSpeed, axisMask):
        """Moves an end-effector to DEPRECATED. Use setPositions function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param std::vector<float> position: 6D position array (x,y,z,wx,wy,wz) in meters and radians
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setPosition(chainName, space, position, fractionMaxSpeed, axisMask)

    def setPositions(self, names, spaces, positions, fractionMaxSpeed, axisMask):
        """Moves multiple end-effectors to the given position and orientation position6d. This is a non-blocking call.

        :param AL::ALValue names: The name or names of effector.
        :param AL::ALValue spaces: The task frame or task frames {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue positions: Position6D arrays
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param AL::ALValue axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setPositions(names, spaces, positions, fractionMaxSpeed, axisMask)

    def setPushRecoveryEnabled(self, pEnable):
        """Enable The push recovery protection for the robot.

        :param bool pEnable: Enable the push recovery.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setPushRecoveryEnabled(pEnable)

    def setSmartStiffnessEnabled(self, pEnable):
        """Enable Smart Stiffness for all the joints (True by default), the update take one motion cycle for updating. The smart Stiffness is a gestion of joint maximum torque. More description is available on the red documentation of ALMotion module.

        :param bool pEnable: Activate or disactivate the smart stiffness.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setSmartStiffnessEnabled(pEnable)

    def setStiffnesses(self, names, stiffnesses):
        """Sets the stiffness of one or more joints. This is a non-blocking call.

        :param AL::ALValue names: Names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue stiffnesses: One or more stiffnesses between zero and one.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setStiffnesses(names, stiffnesses)

    def setTangentialSecurityDistance(self, securityDistance):
        """Defines the tangential security distance used with external collision protection "Move".

        :param float securityDistance: The tangential security distance.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setTangentialSecurityDistance(securityDistance)

    def setTransform(self, chainName, space, transform, fractionMaxSpeed, axisMask):
        """Moves an end-effector to DEPRECATED. Use setTransforms function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param std::vector<float> transform: Transform arrays
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setTransform(chainName, space, transform, fractionMaxSpeed, axisMask)

    def setTransforms(self, names, spaces, transforms, fractionMaxSpeed, axisMask):
        """Moves multiple end-effectors to the given position and orientation transforms. This is a non-blocking call.

        :param AL::ALValue names: The name or names of effector.
        :param AL::ALValue spaces: The task frame or task frames {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue transforms: Transform arrays
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param AL::ALValue axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setTransforms(names, spaces, transforms, fractionMaxSpeed, axisMask)

    def setWalkArmsEnabled(self, leftArmEnabled, rightArmEnabled):
        """DEPRECATED. Sets if Arms Motions are enabled during the Walk Process.

        :param bool leftArmEnabled: if true Left Arm motions are controlled by the Walk Task
        :param bool rightArmEnabled: if true Right Arm mMotions are controlled by the Walk Task
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setWalkArmsEnabled(leftArmEnabled, rightArmEnabled)

    def setWalkTargetVelocity(self, x, y, theta, frequency):
        """DEPRECATED. Use moveToward() function instead.

        :param float x: Fraction of MaxStepX. Use negative for backwards. [-1.0 to 1.0]
        :param float y: Fraction of MaxStepY. Use negative for right. [-1.0 to 1.0]
        :param float theta: Fraction of MaxStepTheta. Use negative for clockwise [-1.0 to 1.0]
        :param float frequency: Fraction of MaxStepFrequency [0.0 to 1.0]
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setWalkTargetVelocity(x, y, theta, frequency)

    def setWalkTargetVelocity2(self, x, y, theta, frequency, feetGaitConfig):
        """DEPRECATED. Use moveToward() function instead.

        :param float x: Fraction of MaxStepX. Use negative for backwards. [-1.0 to 1.0]
        :param float y: Fraction of MaxStepY. Use negative for right. [-1.0 to 1.0]
        :param float theta: Fraction of MaxStepTheta. Use negative for clockwise [-1.0 to 1.0]
        :param float frequency: Fraction of MaxStepFrequency [0.0 to 1.0]
        :param AL::ALValue feetGaitConfig: An ALValue with the custom gait session for both feet
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setWalkTargetVelocity(x, y, theta, frequency, feetGaitConfig)

    def setWalkTargetVelocity3(self, x, y, theta, frequency, leftFootMoveConfig, rightFootMoveConfig):
        """DEPRECATED. Use moveToward() function instead.

        :param float x: Fraction of MaxStepX. Use negative for backwards. [-1.0 to 1.0]
        :param float y: Fraction of MaxStepY. Use negative for right. [-1.0 to 1.0]
        :param float theta: Fraction of MaxStepTheta. Use negative for clockwise [-1.0 to 1.0]
        :param float frequency: Fraction of MaxStepFrequency [0.0 to 1.0]
        :param AL::ALValue leftFootMoveConfig: An ALValue with custom move session for the left foot
        :param AL::ALValue rightFootMoveConfig: An ALValue with custom move session for the right foot
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.setWalkTargetVelocity(x, y, theta, frequency, leftFootMoveConfig, rightFootMoveConfig)

    def stiffnessInterpolation(self, names, stiffnessLists, timeLists):
        """Interpolates one or multiple joints to a target stiffness or along timed trajectories of stiffness. This is a blocking call.

        :param AL::ALValue names: Name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue stiffnessLists: An stiffness, list of stiffnesses or list of list of stiffnesses
        :param AL::ALValue timeLists: A time, list of times or list of list of times.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.stiffnessInterpolation(names, stiffnessLists, timeLists)

    def stopMove(self):
        """Stop Move task safely as fast as possible. The move task is ended less brutally than killMove but more quickly than move(0.0, 0.0, 0.0). This is a blocking call.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.stopMove()

    def stopWalk(self):
        """DEPRECATED. Use stopMove function instead.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.stopWalk()

    def transformInterpolation(self, chainName, space, path, axisMask, duration, isAbsolute):
        """DEPRECATED. Use the other transformInterpolations function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue path: Vector of Transform arrays
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue duration: Vector of times in seconds corresponding to the path points
        :param bool isAbsolute: If true, the movement is absolute else relative
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.transformInterpolation(chainName, space, path, axisMask, duration, isAbsolute)

    def transformInterpolations(self, effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes, isAbsolute):
        """DEPRECATED. Use the other transformInterpolations function instead.

        :param std::vector<std::string> effectorNames: Vector of chain names. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param int taskSpaceForAllPaths: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue paths: Vector of transforms arrays.
        :param AL::ALValue axisMasks: Vector of Axis Masks. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue relativeTimes: Vector of times in seconds corresponding to the path points
        :param bool isAbsolute: If true, the movement is absolute else relative
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.transformInterpolations(effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes, isAbsolute)

    def transformInterpolations2(self, effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes):
        """Moves end-effectors to the given positions and orientations over time. This is a blocking call.

        :param AL::ALValue effectorNames: Vector of chain names. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param AL::ALValue taskSpaceForAllPaths: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue paths: Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
        :param AL::ALValue axisMasks: Vector of Axis Masks. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue relativeTimes: Vector of times in seconds corresponding to the path points
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.transformInterpolations(effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes)

    def updateTrackerTarget(self, pTargetPositionWy, pTargetPositionWz, pTimeSinceDetectionMs, pUseOfWholeBody):
        """Update the target to follow by the head of NAO. DEPRECATED Function. Please use ALTracker::lookAt.

        :param float pTargetPositionWy: The target position wy in FRAME_ROBOT
        :param float pTargetPositionWz: The target position wz in  FRAME_ROBOT
        :param int pTimeSinceDetectionMs: The time in Ms since the target was detected
        :param bool pUseOfWholeBody: If true, the target is follow in cartesian space by the Head with whole Body constraints.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.updateTrackerTarget(pTargetPositionWy, pTargetPositionWz, pTimeSinceDetectionMs, pUseOfWholeBody)

    def version(self):
        """Returns the version of the module.

        :returns str: A string containing the version of the module.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.version()

    def waitUntilMoveIsFinished(self):
        """Waits until the move process is finished: This method can be used to block your script/code execution until the move task is totally finished.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.waitUntilMoveIsFinished()

    def waitUntilWalkIsFinished(self):
        """DEPRECATED. Use waitUntilMoveIsFinished function instead.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.waitUntilWalkIsFinished()

    def wakeUp(self):
        """The robot will wake up: set Motor ON and go to initial position if needed
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.wakeUp()

    def walkInit(self):
        """DEPRECATED. Use moveInit function instead.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.walkInit()

    def walkIsActive(self):
        """DEPRECATED. Use moveIsActive function instead.

        :returns bool: 
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.walkIsActive()

    def walkTo(self, x, y, theta):
        """DEPRECATED. Use moveTo() function instead.

        :param float x: Distance along the X axis in meters.
        :param float y: Distance along the Y axis in meters.
        :param float theta: Rotation around the Z axis in radians [-3.1415 to 3.1415].
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.walkTo(x, y, theta)

    def walkTo2(self, x, y, theta, feetGaitConfig):
        """DEPRECATED. Use moveTo() function instead.

        :param float x: Distance along the X axis in meters.
        :param float y: Distance along the Y axis in meters.
        :param float theta: Rotation around the Z axis in radians [-3.1415 to 3.1415].
        :param AL::ALValue feetGaitConfig: An ALValue with the custom gait session for both feet.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.walkTo(x, y, theta, feetGaitConfig)

    def walkTo3(self, controlPoint):
        """DEPRECATED. Use moveTo() function instead.

        :param AL::ALValue controlPoint: An ALValue with all the control point in NAO SPACE[[x1,y1,theta1], ..., [xN,yN,thetaN]
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.walkTo(controlPoint)

    def walkTo4(self, controlPoint, feetGaitConfig):
        """DEPRECATED. Use moveTo() function instead.

        :param AL::ALValue controlPoint: An ALValue with all the control point in NAO SPACE[[x1,y1,theta1], ..., [xN,yN,thetaN]
        :param AL::ALValue feetGaitConfig: An ALValue with the custom gait session for both feet
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.walkTo(controlPoint, feetGaitConfig)

    def wbEnable(self, isEnabled):
        """UserFriendly Whole Body API: enable Whole Body Balancer. It's a Generalized Inverse Kinematics which deals with cartesian control, balance, redundancy and task priority. The main goal is to generate and stabilized consistent motions without precomputed trajectories and adapt nao's behaviour to the situation. The generalized inverse kinematic problem takes in account equality constraints (keep foot fix), inequality constraints (joint limits, balance, ...) and quadratic minimization (cartesian / articular desired trajectories). We solve each step a quadratic programming on the robot.

        :param bool isEnabled: Active / Disactive Whole Body Balancer.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.wbEnable(isEnabled)

    def wbEnableBalanceConstraint(self, isEnable, supportLeg):
        """UserFriendly Whole Body API: enable to keep balance in support polygon.

        :param bool isEnable: Enable Nao to keep balance.
        :param str supportLeg: Name of the support leg: "Legs", "LLeg", "RLeg".
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.wbEnableBalanceConstraint(isEnable, supportLeg)

    def wbEnableEffectorControl(self, effectorName, isEnabled):
        """UserFriendly Whole Body API: enable whole body cartesian control of an effector.

        :param str effectorName: Name of the effector : "Head", "LArm" or "RArm". Nao goes to posture init. He manages his balance and keep foot fix. "Head" is controlled in rotation. "LArm" and "RArm" are controlled in position.
        :param bool isEnabled: Active / Disactive Effector Control.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.wbEnableEffectorControl(effectorName, isEnabled)

    def wbEnableEffectorOptimization(self, effectorName, isActive):
        """Advanced Whole Body API: enable to control an effector as an optimization.

        :param str effectorName: Name of the effector : "All", "Arms", "Legs", "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso", "Com".
        :param bool isActive: if true, the effector control is taken in acount in the optimization criteria.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.wbEnableEffectorOptimization(effectorName, isActive)

    def wbFootState(self, stateName, supportLeg):
        """UserFriendly Whole Body API: set the foot state: fixed foot, constrained in a plane or free.

        :param str stateName: Name of the foot state. "Fixed" set the foot fixed. "Plane" constrained the Foot in the plane. "Free" set the foot free.
        :param str supportLeg: Name of the foot. "LLeg", "RLeg" or "Legs".
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.wbFootState(stateName, supportLeg)

    def wbGoToBalance(self, supportLeg, duration):
        """Advanced Whole Body API: "Com" go to a desired support polygon. This is a blocking call.

        :param str supportLeg: Name of the support leg: "Legs", "LLeg", "RLeg".
        :param float duration: Time in seconds. Must be upper 0.5 s.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.wbGoToBalance(supportLeg, duration)

    def wbSetEffectorControl(self, effectorName, targetCoordinate):
        """UserFriendly Whole Body API: set new target for controlled effector. This is a non-blocking call.

        :param str effectorName: Name of the effector : "Head", "LArm" or "RArm". Nao goes to posture init. He manages his balance and keep foot fix. "Head" is controlled in rotation. "LArm" and "RArm" are controlled in position.
        :param AL::ALValue targetCoordinate: "Head" is controlled in rotation (WX, WY, WZ). "LArm" and "RArm" are controlled in position (X, Y, Z). TargetCoordinate must be absolute and expressed in FRAME_ROBOT. If the desired position/orientation is unfeasible, target is resize to the nearest feasible motion.
        """
        if not self.proxy:
            self.proxy = self.session.service("ALMotion")
        return self.proxy.wbSetEffectorControl(effectorName, targetCoordinate)
